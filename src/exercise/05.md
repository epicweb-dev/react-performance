# Fix "perf death by a thousand cuts"

## Background

When you're building a sizable real-world application, you're typically going to
need some sort of state management solution. Whatever state management solution
you're using, often you can run into a problem that I call "perf death by a
thousand cuts" which basically means that so many components are updated when
state changes that it becomes a performance bottleneck.

Sometimes performance problems are because a single component is doing something
it shouldn't (running too much code on an interaction). Those are typically
easier to deal with because you can quickly identify the problem and determine a
good solution.

Perf death by a thousand cuts on the other hand doesn't give you an obvious
place to fix the performance problem because none of the components are slow in
isolation, the problem comes when lots of components need to run when there's a
state update.

So how do we fix this performance problem? Remember that every perf problem is
solved by less code. In this case, the perf problem is coming from running too
much code. Often you have components responding to a state change that don't
need to. Often we memoize these with `React.memo`, and we could do that to all
the components in our app, but there are two problems with this:

1. It increases the complexity of our app (because we have to start using
   `useCallback` and `useMemo` for literally everything to take advantage of
   that, meaning you have a bunch of dependency arrays to manage).
2. React's still doing a bunch of work to check whether these components should
   be re-rendered.

So how do we fix this? What if we just put less of our state in the global
store? This is called colocation and it's a really great way to both improve
performance and maintenance of our app at the same time.

For more on this, you can read my blogpost
[State Colocation will make your React app faster](https://kcd.im/colocate-state).

> NOTE: this is a fundamental problem with state management solutions like
> context and redux. However, with MobX it doesn't matter how much of your app
> state lives in a single MobX "store," your components will _only_ update when
> the data they actually _do_ consume changes. That said, colocating state has
> some maintenance benefits so I wouldn't recommend just putting all of your
> state in MobX either.
>
> Another (newer) alternative to MobX is [Recoil](https://recoiljs.org/) which
> solves some pretty narly performance issues. I recommend giving
> [the intro video a watch](https://www.youtube.com/watch?v=_ISAA_Jt9kI) and
> experimenting with it for complex state management situations for which it is
> well suited.

## Exercise

Production deploys:

- [Exercise](https://react-performance.netlify.app/isolated/exercise/05.js)
- [Final](https://react-performance.netlify.app/isolated/final/05.js)

This exercise is a bit contrived to make it simpler for you. Some apps do have
data grids like this and those can definitely suffer from these performance
problems, but you can also imagine that each square in this app is an individual
component in your app that's connected to the global store (either directly or
via it's parent's connection to the store).

ğŸ‘¨â€ğŸ’¼ The product manager has heard complaints from users that typing in the
`<DogInput />` is extremely slow, especially on low-end devices and when there
are lots of elements in the data grid.

We've already memoized the `<ChangingGrid />` and `<Cell />` components, but
it's still slow. So there's still too much code running on every keystroke as
the user types into the `<DogInput />`. As it turns out, the state that the
`<DogInput />` is using is only needed by the `<DogInput />` and we can colocate
that state. So let's go ahead and take that state out of the global context and
put it within the `<DogInput />` component.

## Extra Credit

### 1. ğŸ’¯ separate contexts

[Production deploy](https://react-performance.netlify.app/isolated/final/05.extra-1.js)

Let's say that the state in the `<DogInput />` _does_ need to be global because
it's accessed by many components in the app. So what do we do? Well, another way
to solve this is by separating our app's state logically into domain-specific
context providers. So we can put the state for the dog input and the state for
the rest of our app in different context providers and when the dog input
updates, the grid doesn't need to update.

So for this extra credit, try to make that work. You may find it easier to just
undo all your work so far and start over from scratch to implement this.

### 2. ğŸ’¯ limit the work consuming components do

[Production deploy](https://react-performance.netlify.app/isolated/final/05.extra-2.js)

If you open up the React DevTools Profiler and click "force rerender" then
you'll notice that the `ChangingGrid` takes quite a bit of time on its own that
was ultimately wasted because there were no actual DOM updates.

An alternative solution is to limit the amount of work consuming components have
to do and make it easier to determine whether a component needs to update. So we
know that the `grid` variable isn't actually changing when the `state` changes.
The specific `cell` of the grid state is all that matters for each `Cell`
component (remember this represents each consumer in a typical application, the
point is they each rely on a specific portion of the state, not all of it
necessarily), so we only need to re-render the particular `Cell` if the state it
depends on changes.

So what if we make the `Cell` actually accept a `cell` prop and then put a
middle-man component in there that does the actual consuming of `useAppState()`.
We could rename the `Cell` component to `CellImpl` (Impl is short for
"implementation"). And then the "middle-man" component could be called `Cell`
(which is the one that we actually expose for use). That way if there's a state
update, `Cell` is re-rendered, and it forwards the `cell` to `CellImpl` which is
memoized and will therefore only re-render when `cell` changes.

You may find it easier to just undo all your work so far and start over from
scratch to implement this.

### 3. ğŸ’¯ write an HOC to get a slice of app state

[Production deploy](https://react-performance.netlify.app/isolated/final/05.extra-3.js)

The previous extra credit could be made more generic via a Higher Order
Component. If you make it this far, try to write a higher order component (I
called it `withStateSlice`) to make it easier for us to do the previous
optimization in more places.

> NOTE: this is effectively what react-redux's `connect` higher order component
> does.

## ğŸ¦‰ Elaboration and Feedback

<div>
<span>After the instruction, if you want to remember what you've just learned, then </span>
<a rel="noopener noreferrer" target="_blank" href="https://ws.kcd.im/?ws=React%20Performance%20%E2%9A%A1&e=05%3A%20Fix%20%22perf%20death%20by%20a%20thousand%20cuts%22&em=">
  fill out the elaboration and feedback form.
</a>
</div>
