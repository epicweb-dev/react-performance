# Optimize context value

## Background

The way that context works is that whenever the provided value changes from one
render to another, it triggers a re-render of all the consuming components
(which will re-render whether or not they're memoized).

So take this for example:

```jsx
const CountContext = React.createContext()

function CountProvider(props) {
  const [count, setCount] = React.useState(0)
  const value = [count, setCount]
  return <CountContext.Provider value={value} {...props} />
}
```

Every time the `<CountProvider />` is re-rendered, the `value` is brand new, so
even though the `count` value itself may stay the same, all component consumers
will be re-rendered.

This can be problematic in certain scenarios. You can read more about this here:
https://github.com/kentcdodds/kentcdodds.com/blob/319db97260078ea4c263e75166f05e2cea21ccd1/content/blog/how-to-optimize-your-context-value/index.md

> I wrote about this but it was a little confusing so it's no longer published,
> that's why I'm giving you a link to the original blog post content on GitHub
> üòÖ

The quick and easy solution to this problem is to memoize the value that you
provide to the context provider:

```jsx
const CountContext = React.createContext()

function CountProvider(props) {
  const [count, setCount] = React.useState(0)
  const value = React.useMemo(() => [count, setCount], [count])
  return <CountContext.Provider value={value} {...props} />
}
```

## Exercise

Production deploys:

- [Exercise](https://react-performance.netlify.app/isolated/exercise/06.js)
- [Final](https://react-performance.netlify.app/isolated/final/06.js)

After we fixed the previous performance problem, our üë®‚Äçüíº product manager noticed
another performance problem. Whenever you click on the "force render" button
it's slow. See if you can figure out why and fix that by memoizing the context
value.

Make sure to profile before/after to see whether you actually fixed the problem.

## Extra Credit

### 1. üíØ separate the contexts

[Production deploy](https://react-performance.netlify.app/isolated/final/06.extra-1.js)

After we fixed that performance problem with our app, the üë®‚Äçüíº product manager was
so happy because it was fast enough to add a new feature to the grid. Now you
can update a single cell by clicking on it. But there's a performance problem
with that as well. Every single cell in the grid re-renders when we do that. Not
just the one that was changed!

The reason this is happening is because all the cells consume the provider value
and when the state changes, they need to be re-rendered. But wait... they don't
really depend on the part of the value that's changing, right? They only need
the `dispatch` function. So what if we put the state in one context provider and
the `dispatch` function in another context provider? Hmm.... Give that a try and
see if you can get things to run faster.

## ü¶â Elaboration and Feedback

<div>
<span>After the instruction, if you want to remember what you've just learned, then </span>
<a rel="noopener noreferrer" target="_blank" href="https://ws.kcd.im/?ws=React%20Performance%20%E2%9A%A1&e=06%3A%20Optimize%20context%20value&em=">
  fill out the elaboration and feedback form.
</a>
</div>
